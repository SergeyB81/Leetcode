def print_tree(arr, i=0, level=0):
    if i < len(arr):
        print_tree(arr, i=2 * i + 2, level=level + 1)
        print(3 * ' ' * level + str(arr[i]))
        print_tree(arr, i=2 * i + 1, level=level + 1)


def heapify(arr, i, n):
    """
    Функция восстанавливает свойство кучи для поддерева с корнем в i.

    arr — список элементов (массив)
    i — индекс текущего узла
    n — количество элементов в куче (используется при сортировке, чтобы ограничивать размер кучи)
    """

    # Индекс левого потомка в массиве
    l = 2 * i + 1
    # Индекс правого потомка
    r = 2 * i + 2

    # Изначально считаем, что текущий узел (i) — наибольший
    largest = i

    # Если левый потомок существует и больше текущего наибольшего — обновляем
    if l < n and arr[l] > arr[largest]:
        largest = l

    # То же самое для правого потомка
    if r < n and arr[r] > arr[largest]:
        largest = r

    # Если наибольший элемент — не текущий узел
    if largest != i:
        # Меняем местами текущий элемент и наибольший потомок
        arr[i], arr[largest] = arr[largest], arr[i]

        # Рекурсивно вызываем heapify для поддерева, на котором произошла перестановка
        heapify(arr, largest, n)


def heap_sort(arr):
    """
    Основная функция сортировки массива методом Heap Sort.
    arr — список элементов, который нужно отсортировать
    """

    n = len(arr)  # Длина массива

    # Шаг 1: Построение max-heap (максимальной кучи)
    # Начинаем с последнего родительского узла и поднимаемся к корню
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, i, n)

    # Шаг 2: Извлекаем элементы из кучи один за другим
    for i in range(n - 1, 0, -1):
        # Перемещаем текущий корень (наибольший элемент) в конец массива
        arr[0], arr[i] = arr[i], arr[0]

        # Восстанавливаем кучу на оставшемся диапазоне
        heapify(arr, 0, i)


#Как это работает на примере:
#Допустим, у нас есть массив [4, 10, 3, 5, 1].
#Сначала строится max-heap: корень дерева будет наибольшим элементом.
#Затем наибольший элемент (в начале массива) меняется местами с последним элементом.
#Массив уменьшается на 1 (последний элемент уже отсортирован), и процесс повторяется.
#В результате массив будет отсортирован по возрастанию.

if __name__ == '__main__':
    nums = [1, 8, 3, 0, 10]
    print_tree(nums)

    print('-'*79)

   # heapify(nums,0,5)
   # print_tree(nums)
   # print(nums)


    heap_sort(nums)
    print(nums)

    print_tree(nums)
    # rep5


