def find_max_unique(string):
    """
    Находит максимальную подстроку с уникальными символами в строке.

    Алгоритм использует метод sliding window с двумя указателями и хэш-таблицей
    для отслеживания последних позиций символов.

    Args:
        string (str): Входная строка

    Returns:
        str: Подстрока с уникальными символами максимальной длины
    """
    # Инициализация переменной для хранения максимальной найденной подстроки
    max_arr = ''

    # Указатель начала текущего окна (подстроки с уникальными символами)
    start = 0

    # Словарь для хранения последних индексов встречи каждого символа
    # Ключ: символ, Значение: последний индекс где он был встречен
    indexes = {}

    # Множество для отслеживания уникальных символов в текущем окне
    uniq = set([])

    # Основной цикл: проходим по всем символам строки с их индексами
    for i, si in enumerate(string):
        # Проверяем, есть ли текущий символ уже в текущем множестве уникальных символов
        if si in uniq:
            # Если символ уже есть в текущем окне, значит найдено повторение
            # Сравниваем текущую максимальную подстроку с подстрокой от start до i
            # и выбираем более длинную с помощью lambda-функции
            max_arr = max(max_arr, string[start:i], key=lambda x: len(x))

            # Сдвигаем начало окна на позицию после последнего вхождения повторяющегося символа
            start = indexes[si] + 1

            # Пересоздаем множество уникальных символов для нового окна
            # Берем подстроку от нового start до текущей позиции i
            uniq = set(string[start:i])

        # Обновляем словарь индексов - запоминаем текущую позицию для данного символа
        indexes[si] = i

        # Добавляем текущий символ в множество уникальных символов текущего окна
        uniq.add(si)

    # После завершения основного цикла проверяем последнее окно
    # (от start до конца строки) и сравниваем с максимальной найденной подстрокой
    max_arr = max(max_arr, string[start:], key=lambda x: len(x))

    # Возвращаем найденную подстроку максимальной длины с уникальными символами
    return max_arr


# Альтернативный более эффективный вариант (комментарий для сравнения)
"""
Более оптимальная реализация без пересоздания множества на каждом повторении:

def find_max_unique_optimized(s: str) -> str:
    char_index = {}
    max_sub = ""
    left = 0

    for right in range(len(s)):
        if s[right] in char_index and char_index[s[right]] >= left:
            left = char_index[s[right]] + 1
        char_index[s[right]] = right

        if right - left + 1 > len(max_sub):
            max_sub = s[left:right+1]

    return max_sub
"""


# Тестирование функции
if __name__ == "__main__":
    # Тестовые примеры
    test_cases = [
        "abcabcbb",  # "abc"
        "bbbbb",  # "b"
        "pwwkew",  # "wke"
        "",  # ""
        "a",  # "a"
        "abcd",  # "abcd"
        "aab"  # "ab"
    ]

    for test in test_cases:
        result = find_max_unique(test)
        print(f"Строка: '{test}' -> Макс. уникальная подстрока: '{result}' (длина: {len(result)})")