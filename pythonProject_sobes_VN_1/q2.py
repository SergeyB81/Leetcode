"""
Задача:
Напишите функцию, которая принимает положительное целое число и возвращает следующее меньшее положительное целое число,
содержащее те же цифры. Если такого числа не существует, верните -1.
"""


def next_smaller(n):
    digits = list(str(n))
    length = len(digits)

    # Находим точку, где можно сделать число меньше
    pivot = length - 2
    while pivot >= 0 and digits[pivot] <= digits[pivot + 1]:
        pivot -= 1

    if pivot == -1:
        return -1  # Нет меньшего числа с теми же цифрами

    # Находим наибольшую цифру справа от pivot, которая меньше digits[pivot]
    swap = length - 1
    while digits[swap] >= digits[pivot]:
        swap -= 1

    # Меняем местами
    digits[pivot], digits[swap] = digits[swap], digits[pivot]

    # Разворачиваем оставшуюся часть справа от pivot
    digits[pivot + 1:] = digits[pivot + 1:][::-1]

    # Проверяем, что число не начинается с нуля
    if digits[0] == '0':
        return -1

    result = int(''.join(digits))
    return result if result < n else -1


print(next_smaller(21078))
print(next_smaller(21))    # 12
print(next_smaller(531))   # 513
print(next_smaller(2071))  # 2017
print(next_smaller(9))     # -1
print(next_smaller(111))   # -1
print(next_smaller(135))   # -1
print(next_smaller(1027))  # -1 (0172 не считается, так как начинается с 0)


""""
Ход выполнения:
1. Преобразование числа в список цифр для обработки.
2. Поиск точки разрыва (pivot) - места, где можно сделать число меньше.
3. Если точка не найдена (все цифры в порядке возрастания), возвращаем -1.
4. Поиск наибольшей цифры справа от pivot, которая меньше цифры в pivot.
5. Обмен найденной цифры с цифрой в pivot.
6. Разворот оставшейся части справа от pivot для получения максимально возможного уменьшения.
7. Проверка, что результат не начинается с нуля (такие числа не считаются валидными).
8. Возврат результата, если он соответствует условиям задачи.
"""
"""

Функция находит следующее меньшее число с теми же цифрами.
Возвращает -1, если такого числа не существует.

Пошаговый алгоритм:
1. Начинаем с конца числа (последней цифры) и движемся влево
2. Ищем первую цифру d, которая больше следующей за ней (digits[pivot] > digits[pivot+1])
   - Это означает, что если заменить d на меньшую цифру из правой части, число уменьшится
3. Если такой цифры нет (все цифры в неубывающем порядке), значит число уже минимально
   возможное (например 12345), и возвращаем -1
"""