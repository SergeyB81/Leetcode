from collections import deque

def word_ladder(begin_word, end_word, word_list):
    """
    Алгоритм "Лестница слов" - поиск кратчайшего пути преобразования одного слова в другое
    с изменением по одной букве за шаг, где все промежуточные слова должны существовать в словаре.

    Args:
        begin_word (str): начальное слово
        end_word (str): целевое слово
        word_list (list): список допустимых слов

    Returns:
        int: минимальное количество шагов преобразования или 0, если путь невозможен
    """

    # Преобразуем список слов в множество для быстрого поиска (O(1) вместо O(n))
    word_set = set(word_list)

    # Проверяем, существует ли конечное слово в словаре
    # Если нет - преобразование невозможно
    if end_word not in word_set:
        return 0

    # Создаем очередь для BFS (поиска в ширину)
    # Храним кортежи: (текущее_слово, количество_шагов_до_него)
    # Начинаем с начального слова и 1 шага (само начальное слово считается шагом 1)
    queue = deque([(begin_word, 1)])

    # Множество для отслеживания уже посещенных слов
    # Это предотвращает бесконечные циклы и повторные обработки
    visited = set()
    visited.add(begin_word)

    # Основной цикл BFS - обрабатываем слова пока очередь не пуста
    while queue:
        # Извлекаем слово из начала очереди (FIFO - First In First Out)
        current_word, steps = queue.popleft()

        # Базовый случай: если достигли целевого слова
        if current_word == end_word:
            return steps  # Возвращаем количество шагов

        # Генерируем всех возможных "соседей" - слов, отличающихся на одну букву
        # Проходим по каждой позиции в слове
        for i in range(len(current_word)):
            # Для каждой позиции пробуем все буквы английского алфавита
            for c in 'abcdefghijklmnopqrstuvwxyz':
                # Создаем новое слово: заменяем i-ю букву на c
                # Формируем: часть ДО i-й позиции + новая буква + часть ПОСЛЕ i-й позиции
                next_word = current_word[:i] + c + current_word[i + 1:]

                # Проверяем два условия:
                # 1. Новое слово существует в нашем словаре
                # 2. Мы еще не посещали это слово (избегаем циклов)
                if next_word in word_set and next_word not in visited:
                    # Добавляем слово в посещенные
                    visited.add(next_word)
                    # Добавляем в очередь для дальнейшего исследования
                    # Увеличиваем счетчик шагов на 1
                    queue.append((next_word, steps + 1))

    # Если очередь опустела, а целевое слово не найдено
    # Это означает, что преобразование невозможно
    return 0


# Пример использования:
begin_word = "same"
end_word = "cost"
word_list = ["same", "came", "case", "cast", "lost", "last", "cost"]

print(word_ladder(begin_word, end_word, word_list))  # Вывод: 5